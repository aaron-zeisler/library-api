// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/aaron-zeisler/library-api/internal"
)

type MockBooksDB struct {
	CreateBookStub        func(context.Context, string, string, string, string) (internal.Book, error)
	createBookMutex       sync.RWMutex
	createBookArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}
	createBookReturns struct {
		result1 internal.Book
		result2 error
	}
	createBookReturnsOnCall map[int]struct {
		result1 internal.Book
		result2 error
	}
	DeleteBookStub        func(context.Context, string) error
	deleteBookMutex       sync.RWMutex
	deleteBookArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteBookReturns struct {
		result1 error
	}
	deleteBookReturnsOnCall map[int]struct {
		result1 error
	}
	GetBookByIDStub        func(context.Context, string) (internal.Book, error)
	getBookByIDMutex       sync.RWMutex
	getBookByIDArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getBookByIDReturns struct {
		result1 internal.Book
		result2 error
	}
	getBookByIDReturnsOnCall map[int]struct {
		result1 internal.Book
		result2 error
	}
	GetBooksStub        func(context.Context) ([]internal.Book, error)
	getBooksMutex       sync.RWMutex
	getBooksArgsForCall []struct {
		arg1 context.Context
	}
	getBooksReturns struct {
		result1 []internal.Book
		result2 error
	}
	getBooksReturnsOnCall map[int]struct {
		result1 []internal.Book
		result2 error
	}
	UpdateBookStub        func(context.Context, string, string, string, string, string) (internal.Book, error)
	updateBookMutex       sync.RWMutex
	updateBookArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
	}
	updateBookReturns struct {
		result1 internal.Book
		result2 error
	}
	updateBookReturnsOnCall map[int]struct {
		result1 internal.Book
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *MockBooksDB) CreateBook(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string) (internal.Book, error) {
	fake.createBookMutex.Lock()
	ret, specificReturn := fake.createBookReturnsOnCall[len(fake.createBookArgsForCall)]
	fake.createBookArgsForCall = append(fake.createBookArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.CreateBookStub
	fakeReturns := fake.createBookReturns
	fake.recordInvocation("CreateBook", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.createBookMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MockBooksDB) CreateBookCallCount() int {
	fake.createBookMutex.RLock()
	defer fake.createBookMutex.RUnlock()
	return len(fake.createBookArgsForCall)
}

func (fake *MockBooksDB) CreateBookCalls(stub func(context.Context, string, string, string, string) (internal.Book, error)) {
	fake.createBookMutex.Lock()
	defer fake.createBookMutex.Unlock()
	fake.CreateBookStub = stub
}

func (fake *MockBooksDB) CreateBookArgsForCall(i int) (context.Context, string, string, string, string) {
	fake.createBookMutex.RLock()
	defer fake.createBookMutex.RUnlock()
	argsForCall := fake.createBookArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *MockBooksDB) CreateBookReturns(result1 internal.Book, result2 error) {
	fake.createBookMutex.Lock()
	defer fake.createBookMutex.Unlock()
	fake.CreateBookStub = nil
	fake.createBookReturns = struct {
		result1 internal.Book
		result2 error
	}{result1, result2}
}

func (fake *MockBooksDB) CreateBookReturnsOnCall(i int, result1 internal.Book, result2 error) {
	fake.createBookMutex.Lock()
	defer fake.createBookMutex.Unlock()
	fake.CreateBookStub = nil
	if fake.createBookReturnsOnCall == nil {
		fake.createBookReturnsOnCall = make(map[int]struct {
			result1 internal.Book
			result2 error
		})
	}
	fake.createBookReturnsOnCall[i] = struct {
		result1 internal.Book
		result2 error
	}{result1, result2}
}

func (fake *MockBooksDB) DeleteBook(arg1 context.Context, arg2 string) error {
	fake.deleteBookMutex.Lock()
	ret, specificReturn := fake.deleteBookReturnsOnCall[len(fake.deleteBookArgsForCall)]
	fake.deleteBookArgsForCall = append(fake.deleteBookArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteBookStub
	fakeReturns := fake.deleteBookReturns
	fake.recordInvocation("DeleteBook", []interface{}{arg1, arg2})
	fake.deleteBookMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *MockBooksDB) DeleteBookCallCount() int {
	fake.deleteBookMutex.RLock()
	defer fake.deleteBookMutex.RUnlock()
	return len(fake.deleteBookArgsForCall)
}

func (fake *MockBooksDB) DeleteBookCalls(stub func(context.Context, string) error) {
	fake.deleteBookMutex.Lock()
	defer fake.deleteBookMutex.Unlock()
	fake.DeleteBookStub = stub
}

func (fake *MockBooksDB) DeleteBookArgsForCall(i int) (context.Context, string) {
	fake.deleteBookMutex.RLock()
	defer fake.deleteBookMutex.RUnlock()
	argsForCall := fake.deleteBookArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *MockBooksDB) DeleteBookReturns(result1 error) {
	fake.deleteBookMutex.Lock()
	defer fake.deleteBookMutex.Unlock()
	fake.DeleteBookStub = nil
	fake.deleteBookReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockBooksDB) DeleteBookReturnsOnCall(i int, result1 error) {
	fake.deleteBookMutex.Lock()
	defer fake.deleteBookMutex.Unlock()
	fake.DeleteBookStub = nil
	if fake.deleteBookReturnsOnCall == nil {
		fake.deleteBookReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteBookReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MockBooksDB) GetBookByID(arg1 context.Context, arg2 string) (internal.Book, error) {
	fake.getBookByIDMutex.Lock()
	ret, specificReturn := fake.getBookByIDReturnsOnCall[len(fake.getBookByIDArgsForCall)]
	fake.getBookByIDArgsForCall = append(fake.getBookByIDArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetBookByIDStub
	fakeReturns := fake.getBookByIDReturns
	fake.recordInvocation("GetBookByID", []interface{}{arg1, arg2})
	fake.getBookByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MockBooksDB) GetBookByIDCallCount() int {
	fake.getBookByIDMutex.RLock()
	defer fake.getBookByIDMutex.RUnlock()
	return len(fake.getBookByIDArgsForCall)
}

func (fake *MockBooksDB) GetBookByIDCalls(stub func(context.Context, string) (internal.Book, error)) {
	fake.getBookByIDMutex.Lock()
	defer fake.getBookByIDMutex.Unlock()
	fake.GetBookByIDStub = stub
}

func (fake *MockBooksDB) GetBookByIDArgsForCall(i int) (context.Context, string) {
	fake.getBookByIDMutex.RLock()
	defer fake.getBookByIDMutex.RUnlock()
	argsForCall := fake.getBookByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *MockBooksDB) GetBookByIDReturns(result1 internal.Book, result2 error) {
	fake.getBookByIDMutex.Lock()
	defer fake.getBookByIDMutex.Unlock()
	fake.GetBookByIDStub = nil
	fake.getBookByIDReturns = struct {
		result1 internal.Book
		result2 error
	}{result1, result2}
}

func (fake *MockBooksDB) GetBookByIDReturnsOnCall(i int, result1 internal.Book, result2 error) {
	fake.getBookByIDMutex.Lock()
	defer fake.getBookByIDMutex.Unlock()
	fake.GetBookByIDStub = nil
	if fake.getBookByIDReturnsOnCall == nil {
		fake.getBookByIDReturnsOnCall = make(map[int]struct {
			result1 internal.Book
			result2 error
		})
	}
	fake.getBookByIDReturnsOnCall[i] = struct {
		result1 internal.Book
		result2 error
	}{result1, result2}
}

func (fake *MockBooksDB) GetBooks(arg1 context.Context) ([]internal.Book, error) {
	fake.getBooksMutex.Lock()
	ret, specificReturn := fake.getBooksReturnsOnCall[len(fake.getBooksArgsForCall)]
	fake.getBooksArgsForCall = append(fake.getBooksArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetBooksStub
	fakeReturns := fake.getBooksReturns
	fake.recordInvocation("GetBooks", []interface{}{arg1})
	fake.getBooksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MockBooksDB) GetBooksCallCount() int {
	fake.getBooksMutex.RLock()
	defer fake.getBooksMutex.RUnlock()
	return len(fake.getBooksArgsForCall)
}

func (fake *MockBooksDB) GetBooksCalls(stub func(context.Context) ([]internal.Book, error)) {
	fake.getBooksMutex.Lock()
	defer fake.getBooksMutex.Unlock()
	fake.GetBooksStub = stub
}

func (fake *MockBooksDB) GetBooksArgsForCall(i int) context.Context {
	fake.getBooksMutex.RLock()
	defer fake.getBooksMutex.RUnlock()
	argsForCall := fake.getBooksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *MockBooksDB) GetBooksReturns(result1 []internal.Book, result2 error) {
	fake.getBooksMutex.Lock()
	defer fake.getBooksMutex.Unlock()
	fake.GetBooksStub = nil
	fake.getBooksReturns = struct {
		result1 []internal.Book
		result2 error
	}{result1, result2}
}

func (fake *MockBooksDB) GetBooksReturnsOnCall(i int, result1 []internal.Book, result2 error) {
	fake.getBooksMutex.Lock()
	defer fake.getBooksMutex.Unlock()
	fake.GetBooksStub = nil
	if fake.getBooksReturnsOnCall == nil {
		fake.getBooksReturnsOnCall = make(map[int]struct {
			result1 []internal.Book
			result2 error
		})
	}
	fake.getBooksReturnsOnCall[i] = struct {
		result1 []internal.Book
		result2 error
	}{result1, result2}
}

func (fake *MockBooksDB) UpdateBook(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string, arg6 string) (internal.Book, error) {
	fake.updateBookMutex.Lock()
	ret, specificReturn := fake.updateBookReturnsOnCall[len(fake.updateBookArgsForCall)]
	fake.updateBookArgsForCall = append(fake.updateBookArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.UpdateBookStub
	fakeReturns := fake.updateBookReturns
	fake.recordInvocation("UpdateBook", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.updateBookMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *MockBooksDB) UpdateBookCallCount() int {
	fake.updateBookMutex.RLock()
	defer fake.updateBookMutex.RUnlock()
	return len(fake.updateBookArgsForCall)
}

func (fake *MockBooksDB) UpdateBookCalls(stub func(context.Context, string, string, string, string, string) (internal.Book, error)) {
	fake.updateBookMutex.Lock()
	defer fake.updateBookMutex.Unlock()
	fake.UpdateBookStub = stub
}

func (fake *MockBooksDB) UpdateBookArgsForCall(i int) (context.Context, string, string, string, string, string) {
	fake.updateBookMutex.RLock()
	defer fake.updateBookMutex.RUnlock()
	argsForCall := fake.updateBookArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *MockBooksDB) UpdateBookReturns(result1 internal.Book, result2 error) {
	fake.updateBookMutex.Lock()
	defer fake.updateBookMutex.Unlock()
	fake.UpdateBookStub = nil
	fake.updateBookReturns = struct {
		result1 internal.Book
		result2 error
	}{result1, result2}
}

func (fake *MockBooksDB) UpdateBookReturnsOnCall(i int, result1 internal.Book, result2 error) {
	fake.updateBookMutex.Lock()
	defer fake.updateBookMutex.Unlock()
	fake.UpdateBookStub = nil
	if fake.updateBookReturnsOnCall == nil {
		fake.updateBookReturnsOnCall = make(map[int]struct {
			result1 internal.Book
			result2 error
		})
	}
	fake.updateBookReturnsOnCall[i] = struct {
		result1 internal.Book
		result2 error
	}{result1, result2}
}

func (fake *MockBooksDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createBookMutex.RLock()
	defer fake.createBookMutex.RUnlock()
	fake.deleteBookMutex.RLock()
	defer fake.deleteBookMutex.RUnlock()
	fake.getBookByIDMutex.RLock()
	defer fake.getBookByIDMutex.RUnlock()
	fake.getBooksMutex.RLock()
	defer fake.getBooksMutex.RUnlock()
	fake.updateBookMutex.RLock()
	defer fake.updateBookMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *MockBooksDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
